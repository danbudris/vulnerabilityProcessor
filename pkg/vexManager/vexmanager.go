package vexManager

import (
	"encoding/json"

	"fmt"
	"os"

	"github.com/danbudris/vulnerabilityProcessor/pkg/vex"
)

type Manager struct {
	document                  *vex.Vex
	vulnerabilityToProductMap map[string] []vex.Product
	productVulnerabilityMap   map[string] []vex.Vulnerability
	vulnerabilities           map[string] vex.Vulnerability
}

func New(filepath string) (*Manager, error) {
	m := &Manager{}
	err := m.LoadFromFile(filepath)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (m *Manager) LoadFromFile(filepath string) error {
	b, err := os.ReadFile(filepath)
	if err != nil {
		return fmt.Errorf("loading vex file: %v", err)
	}
	v := &vex.Vex{}
	err = json.Unmarshal(b, v)
	if err != nil {
		return fmt.Errorf("marshalling vex document: %v", err)
	}
	m.document = v
	m.vulnerabilities = cveIdToVulnerabilitiesMap(m.document)
	return err
}

func (m *Manager) Document() *vex.Vex {
	return m.document
}

func (m *Manager) GetProductById(id string) vex.Product {
	if id == "" {
		return vex.Product{}
	}
	for _, b := range m.document.ProductTree.Branches {
		if b.Product.ProductId == id {
			return b.Product
		}
		if len(b.Branches) > 0 {
			return m.GetProductById(id)
		}
	}
	return vex.Product{}
}

func (m *Manager) GetCveById(id string) vex.Vulnerability {
	if id == "" {
		return vex.Vulnerability{}
	}
	for _, c := range m.document.Vulnerabilities {
		if c.Cve == id {
			return c
		}
	}
	return vex.Vulnerability{}
}

func cveIdToVulnerabilitiesMap(v *vex.Vex) map[string] vex.Vulnerability {
	vm := make(map[string] vex.Vulnerability)
	if v == nil {
		return vm
	}
	for _, v := range v.Vulnerabilities {
		vm[v.Cve] = v
	}
	return vm
}
