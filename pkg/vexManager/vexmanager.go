package vexManager

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"

	"github.com/danbudris/vulnerabilityProcessor/pkg/logger"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vex"
)

const (
	statusFixed = "fixed"
	statusKnownAffected = "known_affected"
	statusKnownNotAffected = "known_not_affected"
	statusUnderInvestigation = "under_investigation"
)

type Manager struct {
	document                    *vex.Vex
	vulnerabilityProductPairs   map[productCvePair] *productVulnerabilityStatus
	vulnerabilityToProductIndex map[string] []*vex.Product
	productVulnerabilityIndex   map[string] map[string] string
	vulnerabilityIndex          map[string] *vex.Vulnerability
	productIndex                map[string] *vex.Product
	filePath                    string
}

type productVulnerabilityStatus struct {
	Fixed              []string `json:"fixed,omitempty"`
	KnownAffected      []string `json:"known_affected,omitempty"`
	KnownNotAffected   []string `json:"known_not_affected,omitempty"`
	Recommended        []string `json:"recommended,omitempty"`
	UnderInvestigation []string `json:"under_investigation,omitempty"`
}

type productCvePair struct {
	product string
	cve     string
}

func New(filepath string) (*Manager, error) {
	m := &Manager{}
	v, err := loadVexFromFile(filepath)
	if err != nil {
		return nil, err
	}
	m.filePath = filepath
	m.document = v
	m.indexVulnerabilities()
	m.indexProductTree(m.document.ProductTree.Branches)
	m.initializeProductVulnerabilityStatus()
	m.indexProductVulnerabilityStatus()
	return m, nil
}

func loadVexFromBytes(b []byte) (*vex.Vex, error) {
	v := &vex.Vex{}
	err := json.Unmarshal(b, v)
	if err != nil {
		return nil, fmt.Errorf("marshalling vex document: %v", err)
	}
	return v, nil
}

func loadVexFromFile(filepath string) (*vex.Vex, error) {
	b, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("loading vex file: %v", err)
	}
	v := &vex.Vex{}
	err = json.Unmarshal(b, v)
	if err != nil {
		return nil, fmt.Errorf("marshalling vex document: %v", err)
	}
	return v, err
}

func (m *Manager) Reload() error {
	v, err := loadVexFromFile(m.filePath)
	if err != nil {
		return fmt.Errorf("realoding vex document %s: %v", m.filePath, err)
	}
	m.document = v
	m.indexVulnerabilities()
	m.indexProductTree(m.document.ProductTree.Branches)
	m.initializeProductVulnerabilityStatus()
	m.indexProductVulnerabilityStatus()
	return nil
}

func (m *Manager) Document() vex.Vex {
	return *m.document
}

func (m *Manager) Filepath() string {
	return m.filePath
}

func (m *Manager) DocumentJson() ([]byte, error) {
	b, err := json.Marshal(m.document)
	if err != nil {
		return nil, fmt.Errorf("marshing VEX document to JSON bytes: %v", err)
	}
	buf := &bytes.Buffer{}
	err = json.Indent(buf, b, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("indenting JSON: %v", err)
	}
	return buf.Bytes(), nil
}

func (m *Manager) SetFilepath(filepath string) error {
	logger.V(3).Info("Setting filepath of VEX document and reloading", "filepath", filepath)
	m.filePath = filepath
	err := m.Reload()
	if err != nil {
		return fmt.Errorf("setting filepath for vex manager: %v", err)
	}
	return nil
}

func (m *Manager) GetProduct(id string) *vex.Product {
	return m.productIndex[id]
}

func (m *Manager) GetVulnerability(id string) *vex.Vulnerability {
	return m.vulnerabilityIndex[id]
}

func (m *Manager) InsertVulnerability(v *vex.Vulnerability) {
	v, ok := m.vulnerabilityIndex[v.Cve]; if !ok {
		m.document.Vulnerabilities = append(m.document.Vulnerabilities, v)
		m.vulnerabilityIndex[v.Cve] = v
	}
	m.indexProductVulnerabilityStatus()
}

func (m *Manager) indexVulnerabilities() {
	if m.vulnerabilityIndex == nil {
		m.vulnerabilityIndex = make(map[string] *vex.Vulnerability)
	}
	for _, v := range m.document.Vulnerabilities {
		m.vulnerabilityIndex[v.Cve] = v
	}
}

func (m *Manager) indexProductTree(b []vex.ProductBranch) {
	if m.productIndex == nil {
		m.productIndex = make(map[string] *vex.Product)
	}
	for _, pb := range b {
		if pb.Product != nil {
			m.productIndex[pb.Product.ProductId] = pb.Product
		}
		if len(pb.Branches) > 0 {
			m.indexProductTree(pb.Branches)
		}
	}
}

func (m *Manager) indexProductVulnerabilityStatus() {
	for _, v := range m.vulnerabilityIndex {
		for _, p := range v.ProductStatus.KnownNotAffected {
			m.productVulnerabilityIndex[p][v.Cve] = statusKnownNotAffected
		}
		for _, p := range v.ProductStatus.KnownAffected {
			m.productVulnerabilityIndex[p][v.Cve] = statusKnownAffected
		}
		for _, p := range v.ProductStatus.Fixed {
			m.productVulnerabilityIndex[p][v.Cve] = statusFixed
		}
		for _, p := range v.ProductStatus.UnderInvestigation {
			m.productVulnerabilityIndex[p][v.Cve] = statusUnderInvestigation
		}
	}
}

func (m *Manager) initializeProductVulnerabilityStatus() {
	if m.productVulnerabilityIndex == nil {
		m.productVulnerabilityIndex = make(map[string] map[string] string)
	}
	for _, p := range m.productIndex {
		m.productVulnerabilityIndex[p.ProductId] = make(map[string]string)
	}
}