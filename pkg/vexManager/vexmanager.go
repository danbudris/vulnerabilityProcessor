package vexManager

import (
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/aws/aws-sdk-go/service/inspector2"

	"github.com/danbudris/vulnerabilityProcessor/pkg/logger"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vex"
)

const (
	statusFixed = "fixed"
	statusKnownAffected = "known_affected"
	statusKnownNotAffected = "known_not_affected"
	statusUnderInvestigation = "under_investigation"
)

type Manager struct {
	document                    *vex.Vex
	vulnerabilityProductPairs   map[productCvePair] *productVulnerabilityStatus
	vulnerabilityToProductIndex map[string] []*vex.Product
	productVulnerabilityIndex   map[string] map[string] string
	vulnerabilityIndex          map[string] *vex.Vulnerability
	productIndex                map[string] *vex.Product
}

type productVulnerabilityStatus struct {
	Fixed              []string `json:"fixed,omitempty"`
	KnownAffected      []string `json:"known_affected,omitempty"`
	KnownNotAffected   []string `json:"known_not_affected,omitempty"`
	Recommended        []string `json:"recommended,omitempty"`
	UnderInvestigation []string `json:"under_investigation,omitempty"`
}

type productCvePair struct {
	product string
	cve     string
}

func New(filepath string) (*Manager, error) {
	m := &Manager{}
	v, err := loadVexFromFile(filepath)
	if err != nil {
		return nil, err
	}
	m.document = v
	m.indexVulnerabilities()
	m.indexProductTree(m.document.ProductTree.Branches)
	m.initializeProductVulnerabilityStatus()
	m.indexProductVulnerabilityStatus()
	return m, nil
}

func loadVexFromFile(filepath string) (*vex.Vex, error) {
	b, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("loading vex file: %v", err)
	}
	v := &vex.Vex{}
	err = json.Unmarshal(b, v)
	if err != nil {
		return nil, fmt.Errorf("marshalling vex document: %v", err)
	}
	return v, err
}

func (m *Manager) Document() *vex.Vex {
	return m.document
}

func (m *Manager) GetProduct(id string) *vex.Product {
	return m.productIndex[id]
}

func (m *Manager) GetVulnerability(id string) *vex.Vulnerability {
	return m.vulnerabilityIndex[id]
}

func (m *Manager) InsertInspectorFinding(f inspector2.Finding) {
	var v *vex.Vulnerability
	v, ok := m.vulnerabilityIndex[*f.PackageVulnerabilityDetails.VulnerabilityId]; if !ok {
		// since the vulnerability does not exist in the index, let's generate a new vulnerability object
		var references []vex.Reference
		for _, url := range f.PackageVulnerabilityDetails.ReferenceUrls {
			r := vex.Reference{
				URL: *url,
			}
			references = append(references, r)
		}

		r := vex.Reference{
			URL: *f.PackageVulnerabilityDetails.SourceUrl,
		}
		references = append(references, r)

		noteBody := fmt.Sprintf("Generated by Vulnerability Processor; version: %s; source: %s; findingArn: %s, findingTimestamp:, %d, processedTimestamp: %d", "v0.0.0-dev", "inspectorv2", *f.FindingArn, f.FirstObservedAt.Unix(), time.Now().Unix())
		note := vex.Note{
			Category: "Attribution",
			Text:     noteBody,
			Title:    "Inspector Finding",
		}
		notes := []vex.Note{note}

		v = &vex.Vulnerability{
			Cve:           *f.PackageVulnerabilityDetails.VulnerabilityId,
			Notes:         notes,
			ProductStatus: vex.ProductStatus{UnderInvestigation: []string{*f.Resources[0].Id}},
			References:    references,
		}
		m.document.Vulnerabilities = append(m.document.Vulnerabilities, v)
	} else {
		// the vulnerability exists in the index; update the existing vulnerability to include the 'under_investigation' status
		_, ok := m.productVulnerabilityIndex[*f.Resources[0].Id]; if !ok {
			v.ProductStatus.UnderInvestigation = append(v.ProductStatus.UnderInvestigation, *f.Resources[0].Id)
		} else {
			logger.V(3).Info("product to vulnerability mapping already exists; Inspector v2 findings should not be duplicated", "productId", f.Resources[0].Id, "finding", f.FindingArn)
		}
	}
}

func (m *Manager) indexVulnerabilities() {
	for _, v := range m.document.Vulnerabilities {
		m.vulnerabilityIndex[v.Cve] = v
	}
}

func (m *Manager) indexProductTree(b []vex.ProductBranch) {
	for _, pb := range b {
		if pb.Product != nil {
			m.productIndex[pb.Product.ProductId] = pb.Product
		}
		if len(pb.Branches) > 0 {
			m.indexProductTree(pb.Branches)
		}
	}
}

func (m *Manager) indexProductVulnerabilityStatus() {
	for _, v := range m.vulnerabilityIndex {
		for _, p := range v.ProductStatus.KnownNotAffected {
			m.productVulnerabilityIndex[p][v.Cve] = statusKnownNotAffected
		}
		for _, p := range v.ProductStatus.KnownAffected {
			m.productVulnerabilityIndex[p][v.Cve] = statusKnownAffected
		}
		for _, p := range v.ProductStatus.Fixed {
			m.productVulnerabilityIndex[p][v.Cve] = statusFixed
		}
		for _, p := range v.ProductStatus.UnderInvestigation {
			m.productVulnerabilityIndex[p][v.Cve] = statusUnderInvestigation
		}
	}
}

func (m *Manager) initializeProductVulnerabilityStatus() {
	for _, p := range m.productIndex {
		m.productVulnerabilityIndex[p.ProductId] = make(map[string]string)
	}
}
