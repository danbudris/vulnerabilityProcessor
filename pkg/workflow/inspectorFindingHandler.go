package workflow

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"

	"github.com/danbudris/vulnerabilityProcessor/pkg/api"
	"github.com/danbudris/vulnerabilityProcessor/pkg/inspectorHelper"
	"github.com/danbudris/vulnerabilityProcessor/pkg/logger"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
)

const (
	inspectorV2VulnerabilitySource = "inspectorV2"
)

func NewInspector(m vexManager.Manager) *inspectorHandler {
	return &inspectorHandler{manager: m}
}

type inspectorHandler struct {
	manager vexManager.Manager
	next    VulnerabilityHandler
}

func (h *inspectorHandler) Handle(ctx context.Context, wCtx *Context, v *api.VulnerabilityFinding) error {
	if v.VulnerabilitySource != inspectorV2VulnerabilitySource {
		return nil
	}
	if wCtx.InspectorFinding == nil {
		return fmt.Errorf("handling inspector finding: no inspector finding associated with workflow context")
	}
	f := wCtx.InspectorFinding
	err := h.handleFinding(*f, v)
	if err != nil {
		logger.Error(err, "handling inspector finding")
	}
	if h.next != nil {
		return h.next.Handle(ctx, wCtx, v)
	}
	return nil
}

func (h *inspectorHandler) SetNextHandler(handler VulnerabilityHandler) {
	h.next = handler
}

func (h *inspectorHandler) handleFinding(f inspectorHelper.InspectorFinding, v *api.VulnerabilityFinding) error {
	inspectorHelper.InsertNewFindingIntoVex(f, v.Vex)
	b, err := json.Marshal(h.manager.Document())
	if err != nil {
		return fmt.Errorf("marshaling inspector finding to json: %v", err)
	}
	buf := &bytes.Buffer{}
	err = json.Indent(buf, b, "", "\t")
	if err != nil {
		return fmt.Errorf("formating inspector finding json: %v", err)
	}
	logger.V(5).Info("Inspector Finding", "finding", buf.Bytes())
	return nil
}
