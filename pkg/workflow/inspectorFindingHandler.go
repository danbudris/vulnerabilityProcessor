package workflow

import (
	"bytes"
	"context"
	"fmt"
	"os"

	"encoding/json"

	"github.com/danbudris/vulnerabilityProcessor/pkg/api"
	"github.com/danbudris/vulnerabilityProcessor/pkg/inspectorHelper"
	"github.com/danbudris/vulnerabilityProcessor/pkg/logger"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
)

const (
	inspectorV2VulnerabilitySource = "inspectorV2"
)

func NewInspector(m vexManager.Manager) *inspectorHandler {
	return &inspectorHandler{manager: m}
}

type inspectorHandler struct {
	manager vexManager.Manager
	next    VulnerabilityHandler
}

func (h *inspectorHandler) Handle(ctx context.Context, wCtx *Context, v *api.VulnerabilityFinding) error {
	if v.VulnerabilitySource != inspectorV2VulnerabilitySource {
		return nil
	}
	f, err :=  inspectorHelper.ReadFindingFromBytes(v.RawEvent)
	if err != nil {
		return fmt.Errorf("reading inspector finding: %v", err)
	}
	err = h.handleFinding(*f, v)
	if err != nil {
		logger.Error(err, "handling inspector finding")
	}
	if h.next != nil {
		return h.next.Handle(ctx, wCtx, v)
	}
	return nil
}

func (h *inspectorHandler) SetNextHandler(handler VulnerabilityHandler) {
	h.next = handler
}

func (h *inspectorHandler) handleFinding(f inspectorHelper.InspectorFinding, v *api.VulnerabilityFinding) error {
	inspectorHelper.InsertNewFindingIntoVex(f, v.Vex)
	b, err := json.Marshal(h.manager.Document())
	if err != nil {
		return fmt.Errorf("marshaling inspector finding to json: %v", err)
	}
	buf := &bytes.Buffer{}
	err = json.Indent(buf, b, "", "\t")
	if err != nil {
		return fmt.Errorf("formating inspector finding json: %v", err)
	}
	_, err = os.Stdout.Write(buf.Bytes())
	if err != nil {
		return fmt.Errorf("writing inspector finding json to stdout: %v", err)
	}
	return nil
}
