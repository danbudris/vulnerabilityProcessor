package workflow

import (
	"context"
	"fmt"
	"github.com/danbudris/vulnerabilityProcessor/pkg/version"
	"strings"

	"github.com/danbudris/vulnerabilityProcessor/pkg/api"
	"github.com/danbudris/vulnerabilityProcessor/pkg/issueManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
)

const (
	issueAutocreatedTemplate = "Issue auto cut by Vulnerability Processor"
)

type GithubIssueCreatorOpts struct {
	Labels *[]string
}

func IssueCreatorHandler(m *vexManager.Manager, i *issueManager.IssueManager, o GithubIssueCreatorOpts) *githubIssueCreatorHandler {
	return &githubIssueCreatorHandler{
		manager: m,
		issueManager: i,
		labels: o.Labels,
	}
}

type githubIssueCreatorHandler struct {
	manager            *vexManager.Manager
	issueManager       *issueManager.IssueManager
	labels             *[]string
	owner              *string
	repo               *string
	next               VulnerabilityHandler
}

func (h *githubIssueCreatorHandler) Handle(ctx context.Context, wCtx *Context, v *api.VulnerabilityFinding) error {
	openState := "open"
	labels := append(*h.labels, contextDependantLabels(*v)...)

	o := &issueManager.CreateIssueOpts{
		Title:    h.issueTitle(*v),
		Body:     h.issueBody(*v, wCtx),
		Labels:   &labels,
		State:    &openState,
	}

	issue, err := h.issueManager.CreateIssue(ctx, o)
	if err != nil {
		return fmt.Errorf("creating issue in handler: %v", err)
	}
	wCtx.AddIssue(*issue.URL)

	if h.next != nil {
		return h.next.Handle(ctx, wCtx, v)
	}
	return nil
}

func (h *githubIssueCreatorHandler) SetNextHandler(handler VulnerabilityHandler) {
	h.next = handler
}

func (h *githubIssueCreatorHandler) issueBody(v api.VulnerabilityFinding, wCtx *Context) *string {
	b := strings.Builder{}
	b.WriteString(issueAutocreatedTemplate)
	b.WriteString(fmt.Sprintf("\nProcessor Version: `%s`", version.Get().GitVersion))
	if wCtx.MessageSource != "" {
		b.WriteString(fmt.Sprintf("\nMessage Source: `%s`", wCtx.MessageSource))
	}
	if wCtx.FindingSource != "" {
		b.WriteString(fmt.Sprintf("\nFinding Source: `%s`", wCtx.FindingSource))
	}
	if wCtx.ExecutionContext != "" {
		b.WriteString(fmt.Sprintf("\nExecution Context: `%s`", wCtx.ExecutionContext))
	}
	b.WriteString("\n\n")

	b.WriteString(fmt.Sprintf("%s vulnerability %s detected in %d resources\n", v.Severity, v.VulnerabilityId, len(v.AffectedResourceIds)))
	for _, r := range v.AffectedResourceIds {
		b.WriteString(fmt.Sprintf("- %s\n", r))
	}
	b.WriteString("\n\n")

	if len(v.AffectedPackages) > 0 {
		b.WriteString("\nAffected Packages: \n")
		for _, p := range v.AffectedPackages {
			b.WriteString(fmt.Sprintf("- %s\n", p.Name))
		}
	}

	if wCtx != nil {
		if wCtx.PullRequests != nil && len(wCtx.PullRequests) > 0 {
			b.WriteString("\nAssociated Pull Requests: \n")
			for _, pr := range wCtx.PullRequests {
				b.WriteString(fmt.Sprintf("- %s\n", pr))
			}
		}
		if wCtx.Issues != nil && len(wCtx.Issues) > 0 {
			b.WriteString("\nAssociated Issues: \n")
			for _, issue := range wCtx.Issues {
				b.WriteString(fmt.Sprintf("- %s\n", issue))
			}
		}
	}

	bs := b.String()
	return &bs
}

func (h *githubIssueCreatorHandler) issueTitle(v api.VulnerabilityFinding) *string {
	t := strings.Builder{}
	t.WriteString(fmt.Sprintf("%s vulnerability %s affecting %d resources", v.Severity, v.Title, len(v.AffectedResourceIds)))
	ts := t.String()
	return &ts
}

func contextDependantLabels(v api.VulnerabilityFinding) []string {
	severityLabelTemplate := "severity/%s"
	var l []string
	l = append(l, fmt.Sprintf(severityLabelTemplate, v.Severity))
	return l
}