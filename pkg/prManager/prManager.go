package prmanager

import (
	"context"
	"errors"
	"fmt"
	"os"
	"time"

	"github.com/danbudris/vulnerabilityProcessor/pkg/git"
	"github.com/google/go-github/v45/github"
	"golang.org/x/oauth2"
)

var client *github.Client
var ctx = context.Background()

type PrCreator struct {
	sourceOwner  string
	sourceRepo   string
	prRepo       string
	prRepoOwner  string
}

type Opts struct {
	SourceOwner string
	SourceRepo  string
	PrRepo      string
	PrRepoOwner string
}

func New(opts *Opts) *PrCreator {
	return &PrCreator{
		sourceOwner: opts.SourceOwner,
		sourceRepo: opts.SourceRepo,
		prRepo: opts.PrRepo,
		prRepoOwner: opts.PrRepoOwner,
	}
}

// getRef returns the commit branch reference object if it exists or creates it
// from the base branch before returning it.
func (p *PrCreator) getRef(commitBranch string, baseBranch string) (ref *github.Reference, err error) {
	if ref, _, err = client.Git.GetRef(ctx, p.sourceOwner, p.sourceRepo, "refs/heads/"+commitBranch); err == nil {
		return ref, nil
	}

	// We consider that an error means the branch has not been found and needs to
	// be created.
	if commitBranch == baseBranch {
		return nil, errors.New("the commit branch does not exist but `-base-branch` is the same as `-commit-branch`")
	}

	var baseRef *github.Reference
	if baseRef, _, err = client.Git.GetRef(ctx, p.sourceOwner, p.sourceRepo, "refs/heads/"+baseBranch); err != nil {
		return nil, err
	}
	newRef := &github.Reference{Ref: github.String("refs/heads/" + commitBranch), Object: &github.GitObject{SHA: baseRef.Object.SHA}}
	ref, _, err = client.Git.CreateRef(ctx, p.sourceOwner, p.sourceRepo, newRef)
	return ref, err
}

// getTree generates the tree to commit based on the given files and the commit
// of the ref you got in getRef.
func (p *PrCreator) getTree(ref *github.Reference, sourceFileBody []byte, destFilePath string) (tree *github.Tree, err error) {
	// Create a tree with what to commit.
	entries := []*github.TreeEntry{}
	entries = append(entries, &github.TreeEntry{Path: github.String(destFilePath), Type: github.String("blob"), Content: github.String(string(sourceFileBody)), Mode: github.String("100644")})

	tree, _, err = client.Git.CreateTree(ctx, p.sourceOwner, p.sourceRepo, *ref.Object.SHA, entries)
	return tree, err
}

// pushCommit creates the commit in the given reference using the given tree.
func (p *PrCreator) pushCommit(ref *github.Reference, tree *github.Tree, authorName string, authorEmail string, commitMessage string) (err error) {
	// Get the parent commit to attach the commit to.
	parent, _, err := client.Repositories.GetCommit(ctx, p.sourceOwner, p.sourceRepo, *ref.Object.SHA, nil)
	if err != nil {
		return err
	}
	// This is not always populated, but is needed.
	parent.Commit.SHA = parent.SHA

	// Create the commit using the tree.
	date := time.Now()
	author := &github.CommitAuthor{Date: &date, Name: &authorName, Email: &authorEmail}
	commit := &github.Commit{Author: author, Message: &commitMessage, Tree: tree, Parents: []*github.Commit{parent.Commit}}
	newCommit, _, err := client.Git.CreateCommit(ctx, p.sourceOwner, p.sourceRepo, commit)
	if err != nil {
		return err
	}

	// Attach the commit to the master branch.
	ref.Object.SHA = newCommit.SHA
	_, _, err = client.Git.UpdateRef(ctx, p.sourceOwner, p.sourceRepo, ref, false)
	return err
}

func (p *PrCreator) createPR(opts *CreatePrOpts) (err error) {
	if opts.PrSubject == "" {
		return errors.New("missing `-pr-title` flag; skipping PR creation")
	}

	if p.prRepoOwner != "" && p.prRepoOwner != p.sourceOwner {
		opts.CommitBranch = fmt.Sprintf("%s:%s", p.sourceOwner, opts.CommitBranch)
	} else {
		p.prRepoOwner = p.sourceOwner
	}

	if p.prRepo == "" {
		p.prRepo = p.sourceRepo
	}

	newPR := &github.NewPullRequest{
		Title:               &opts.PrSubject,
		Head:                &opts.CommitBranch,
		Base:                &opts.PrBranch,
		Body:                &opts.PrDescription,
		MaintainerCanModify: github.Bool(true),
	}

	pr, _, err := client.PullRequests.Create(ctx, p.prRepoOwner, p.prRepo, newPR)
	if err != nil {
		return err
	}

	fmt.Printf("PR created: %s\n", pr.GetHTMLURL())
	return nil
}

type CreatePrOpts struct {
	CommitBranch    string
	BaseBranch      string
	AuthorName      string
	AuthorEmail     string
	CommitMessage   string
	PrSubject       string
	PrBranch        string
	PrDescription   string
	DestFileGitPath string
	SourceFileBody []byte
}

func (p *PrCreator) CreatePr(opts *CreatePrOpts) error {
	token := os.Getenv(git.GithubTokenEnvVar)
	if token == "" {
		return fmt.Errorf("unauthorized: No token present")
	}
	ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: token})
	tc := oauth2.NewClient(ctx, ts)
	client = github.NewClient(tc)

	ref, err := p.getRef(opts.CommitBranch, opts.BaseBranch)
	if err != nil {
		return fmt.Errorf("get/create the commit reference: %s\n", err)
	}
	if ref == nil {
		return fmt.Errorf("the reference is nil")
	}

	tree, err := p.getTree(ref, opts.SourceFileBody, opts.DestFileGitPath)
	if err != nil {
		return fmt.Errorf("creating the tree based on the provided files: %s\n", err)
	}

	if err := p.pushCommit(ref, tree, opts.AuthorName, opts.AuthorEmail, opts.CommitMessage); err != nil {
		return fmt.Errorf("creating the commit: %s\n", err)
	}

	if err := p.createPR(opts); err != nil {
		return fmt.Errorf("creating pull request: %s", err)
	}
	return nil
}