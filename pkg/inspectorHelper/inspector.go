package inspectorHelper

import (
	"fmt"
	"github.com/danbudris/vulnerabilityProcessor/pkg/version"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vex"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
	"time"

	"encoding/json"
)

func InsertNewFindingIntoVex(f InspectorFinding, m *vexManager.Manager) {
	v := FindingToNewVulnerability(f)
	m.InsertVulnerability(v)
}

func FindingToNewVulnerability(f InspectorFinding) *vex.Vulnerability {
	var v *vex.Vulnerability
	var references []vex.Reference
	for _, url := range f.PackageVulnerabilityDetails.ReferenceUrls {
		r := vex.Reference{
			URL: url,
		}
		references = append(references, r)
	}

	r := vex.Reference{
		URL: f.PackageVulnerabilityDetails.SourceUrl,
	}
	references = append(references, r)

	// add a note which indicates where the finding was source from
	noteBody := fmt.Sprintf("Generated by Vulnerability Processor; version: %s; source: %s; findingArn: %s, findingTimestamp:, %s, processedTimestamp: %d", version.Get().GitVersion, "inspectorv2", f.FindingArn, f.FirstObservedAt, time.Now().Unix())
	note := vex.Note{
		Category: "Attribution",
		Text:     noteBody,
		Title:    "Inspector Finding",
	}
	notes := []vex.Note{note}

	var productsUnderInvestigation []string
	for _, p := range f.Resources {
		productsUnderInvestigation = append(productsUnderInvestigation, p.Id)
	}

	v = &vex.Vulnerability{
		Cve:           f.PackageVulnerabilityDetails.VulnerabilityId,
		Notes:         notes,
		ProductStatus: vex.ProductStatus{UnderInvestigation: productsUnderInvestigation},
		References:    references,
	}
	return v
}

func ReadFindingFromBytes(input []byte) (InspectorFinding, error){
	var e InspectorEventbridgeEvent
	var f InspectorFinding

	err := json.Unmarshal(input, &e)
	if err != nil {
		return f, fmt.Errorf("unmarshalling Inspector V2 finding: %v", err)
	}
	b, err := json.Marshal(e.Detail)
	if err != nil {
		return f, fmt.Errorf("marshalling modified inspector finding to JSON: %v", err)
	}
	err = json.Unmarshal(b, &f)
	if err != nil {
		return f, fmt.Errorf("unmarshalling modified inspector finding to struct: %v", err)
	}
	return f, nil
}

func ConvertInspectorTimeFormatToTime(t string) (*time.Time, error) {
	p, err := time.Parse("Jan 2, 2006, 3:04:5 PM", t)
	if err != nil {
		return nil, fmt.Errorf("parsing non-standard inspector finding time: %v", err)
	}
	return &p, nil
}

type InspectorEventbridgeEvent struct {
	Version    string             `json:"version"`
	Id         string             `json:"id"`
	DetailType string             `json:"detail-type"`
	Source     string             `json:"source"`
	Account    string             `json:"account"`
	Time       time.Time          `json:"time"`
	Region     string             `json:"region"`
	Resources  []string           `json:"resources"`
	Detail     InspectorFinding   `json:"detail"`
}

//Inspector Events have a non-RFC compliant time format for their time fields and can't be marshalled into inspector2.Finding; we're using our own type here to get around this.
type InspectorFinding struct {
	AwsAccountId          string  `json:"awsAccountId"`
	Description           string  `json:"description"`
	FindingArn            string  `json:"findingArn"`
	FirstObservedAt       string  `json:"firstObservedAt"`
	InspectorScore        float64 `json:"inspectorScore"`
	InspectorScoreDetails struct {
		AdjustedCvss struct {
			Adjustments   []interface{} `json:"adjustments"`
			CvssSource    string        `json:"cvssSource"`
			Score         float64       `json:"score"`
			ScoreSource   string        `json:"scoreSource"`
			ScoringVector string        `json:"scoringVector"`
			Version       string        `json:"version"`
		} `json:"adjustedCvss"`
	} `json:"inspectorScoreDetails"`
	LastObservedAt              string `json:"lastObservedAt"`
	PackageVulnerabilityDetails struct {
		Cvss []struct {
			BaseScore     float64 `json:"baseScore"`
			ScoringVector string  `json:"scoringVector"`
			Source        string  `json:"source"`
			Version       string  `json:"version"`
		} `json:"cvss"`
		ReferenceUrls      []string `json:"referenceUrls"`
		Source             string   `json:"source"`
		SourceUrl          string   `json:"sourceUrl"`
		VendorCreatedAt    string   `json:"vendorCreatedAt"`
		VendorSeverity     string   `json:"vendorSeverity"`
		VendorUpdatedAt    string   `json:"vendorUpdatedAt"`
		VulnerabilityId    string   `json:"vulnerabilityId"`
		VulnerablePackages []struct {
			Arch            string `json:"arch"`
			Epoch           int    `json:"epoch"`
			Name            string `json:"name"`
			PackageManager  string `json:"packageManager"`
			Release         string `json:"release"`
			SourceLayerHash string `json:"sourceLayerHash"`
			Version         string `json:"version"`
		} `json:"vulnerablePackages"`
	} `json:"packageVulnerabilityDetails"`
	Remediation struct {
		Recommendation struct {
			Text string `json:"text"`
		} `json:"recommendation"`
	} `json:"remediation"`
	Resources []struct {
		Details struct {
			AwsEcrContainerImage struct {
				Architecture   string   `json:"architecture"`
				ImageHash      string   `json:"imageHash"`
				ImageTags      []string `json:"imageTags"`
				Platform       string   `json:"platform"`
				PushedAt       string   `json:"pushedAt"`
				Registry       string   `json:"registry"`
				RepositoryName string   `json:"repositoryName"`
			} `json:"awsEcrContainerImage"`
		} `json:"details"`
		Id        string `json:"id"`
		Partition string `json:"partition"`
		Region    string `json:"region"`
		Type      string `json:"type"`
	} `json:"resources"`
	Severity  string `json:"severity"`
	Status    string `json:"status"`
	Title     string `json:"title"`
	Type      string `json:"type"`
	UpdatedAt string `json:"updatedAt"`
}
