package main

import (
	"context"
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/aws/aws-lambda-go/lambda"

	"github.com/danbudris/vulnerabilityProcessor/pkg/api"
	"github.com/danbudris/vulnerabilityProcessor/pkg/githubContent"
	"github.com/danbudris/vulnerabilityProcessor/pkg/inspectorHelper"
	issuecreator "github.com/danbudris/vulnerabilityProcessor/pkg/issueManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/logger"
	"github.com/danbudris/vulnerabilityProcessor/pkg/messageSources"
	prcreator "github.com/danbudris/vulnerabilityProcessor/pkg/prManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/retier"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vulnerabilitySources"
	"github.com/danbudris/vulnerabilityProcessor/pkg/workflow"
)

const (
	GithubOwnerEnvVar = "OWNER"
	GithubRepoEnvVar = "REPO"
	GithubEmailEnvVar = "GITHUB_EMAIL"
	PullRequestBaseBranchEnvVar = "PR_BRANCH"
	VexDocumentGitPathEnvVar = "VEX_GIT_PATH"
	LoggingVerbosityEnvVar = "LOGGING_VERBOSITY"
	LoggingDefaultVerbosity = "6"
	RetrierMaxTimeout = 380 * time.Second
	RetrierWait = 30 * time.Second
	RetrierMaxRetries = 15
	RetrierBackoffFactor = 1.5
)

func main() {
	lambda.Start(hanldeInspectorLambdaEvent)
}

func hanldeInspectorLambdaEvent(ctx context.Context, event inspectorHelper.InspectorEventbridgeEvent) (string, error) {
	verbosityLevel, present := os.LookupEnv(LoggingVerbosityEnvVar)
	var verbosityLevelInt int
	var err error
	if present {
		verbosityLevelInt, err = strconv.Atoi(verbosityLevel)
		if err != nil {
			logger.Info("failed when setting logging level from environment variable, defaulting", "error", err, "default level", LoggingDefaultVerbosity)
		}
	} else {
		logger.V(2).Info("log level env var not set; defaulting", "default level", 1, "env var", LoggingVerbosityEnvVar)
		verbosityLevelInt = 1
	}

	err = initLogger(verbosityLevelInt)
	if err != nil {
		return "", fmt.Errorf("initializing logger: %v", err)
	}

	owner, present := os.LookupEnv(GithubOwnerEnvVar)
	if !present {
		return "", fmt.Errorf("enviornment variable %s is required but unset in the environment", GithubOwnerEnvVar)
	}
	if owner == "" {
		return "", fmt.Errorf("environment variable %s is required but set to an empty value", GithubOwnerEnvVar)
	}

	repo, present := os.LookupEnv(GithubRepoEnvVar)
	if !present {
		return "", fmt.Errorf("enviornment variable %s is required but unset in the environment", GithubRepoEnvVar)
	}
	if repo == "" {
		return "", fmt.Errorf("environment variable %s is required but set to an empty value", GithubRepoEnvVar)
	}

	email, present := os.LookupEnv(GithubEmailEnvVar)
	if !present {
		return "", fmt.Errorf("enviornment variable %s is required but unset in the environment", GithubEmailEnvVar)
	}
	if email == "" {
		return "", fmt.Errorf("environment variable %s is required but set to an empty value", GithubEmailEnvVar)
	}

	prBranch, present := os.LookupEnv(PullRequestBaseBranchEnvVar)
	if !present {
		return "", fmt.Errorf("enviornment variable %s is required but unset in the environment", PullRequestBaseBranchEnvVar)
	}
	if prBranch == "" {
		return "", fmt.Errorf("environment variable %s is required but set to an empty value", PullRequestBaseBranchEnvVar)
	}


	vexDocumentGitPath, present := os.LookupEnv(VexDocumentGitPathEnvVar)
	if !present {
		return "", fmt.Errorf("enviornment variable %s is required but unset in the environment", VexDocumentGitPathEnvVar)
	}
	if vexDocumentGitPath == "" {
		return "", fmt.Errorf("environment variable %s is required but set to an empty value", VexDocumentGitPathEnvVar)
	}

	retrier := retier.New(RetrierMaxTimeout, retier.WithBackoffFactor(RetrierBackoffFactor), retier.WithMaxRetries(RetrierMaxRetries, RetrierWait))

	gho := &githubContent.Opts{
		Owner: owner,
		File:  "test.vex",
		Repo:  repo,
	}
	content, err := githubContent.GetGithubRepositoryFileContent(ctx, retrier, gho)
	if err != nil {
		return "", err
	}

	// set up the VEX document manager
	v, err := vexManager.NewFromBytes(content)
	if err != nil {
		return "", fmt.Errorf("setting up vex manager: %v", err)
	}

	if v == nil {
		return "vex was nil, wtf?", nil
	}

	// set up the Inspector Event Handler
	inspectorHandler := workflow.NewInspector(*v)

	// set up PR Creator handler
	o := &prcreator.Opts{
		SourceOwner: owner,
		SourceRepo:  repo,
		PrRepo:      repo,
		PrRepoOwner: owner,
	}
	prCreator := prcreator.New(retrier, o)

	prHandlerOpts := workflow.VexPrCreatorOpts{
		AuthorName:         "VEX PR Bot",
		AuthorEmail:        email,
		PrBranch:           prBranch,
		VexDocumentGitPath: vexDocumentGitPath,
	}
	prHandler := workflow.VexPrCreatorHandler(v, prCreator, prHandlerOpts)

	// set up the Issue Creator handler
	issueManagerOpts := &issuecreator.Opts{
		SourceOwner: owner,
		SourceRepo:  repo,
	}
	issueManager := issuecreator.New(retrier, issueManagerOpts)

	issueHandlerOpts := workflow.GithubIssueCreatorOpts{
		Labels: &[]string{"hey", "there", "test"},
	}
	issueHandler := workflow.IssueCreatorHandler(v, issueManager, issueHandlerOpts)

	// set up the handler chain
	prHandler.SetNextHandler(issueHandler)
	inspectorHandler.SetNextHandler(prHandler)

	// set up the workflow context containing context for executing the handler chain
	wCtx := workflow.NewContext()
	wCtx.SetVex(v)
	wCtx.FindingSource = vulnerabilitySources.InspectorV2
	wCtx.MessageSource = messageSources.EventBridge

	vulnerability, err := inspectorEventBridgeEventToVulnerabilityFinding(event, v)
	if err != nil {
		return "", fmt.Errorf("converting InspectorV2 EventBridge event to vulnerabilitiy finding: %v", err)
	}
	wCtx.AddVulnerabilitiy(vulnerability)
	wCtx.InspectorFinding = &event.Detail

	// invoke the handler chain
	return "", inspectorHandler.Handle(ctx, wCtx, vulnerability)
}

func inspectorEventBridgeEventToVulnerabilityFinding(e inspectorHelper.InspectorEventbridgeEvent, vex *vexManager.Manager) (*api.VulnerabilityFinding, error) {
	var affectedResourceIds []string
	for _, r := range e.Detail.Resources {
		affectedResourceIds = append(affectedResourceIds, r.Id)
	}

	var affectedPackages []api.Package
	for _, p := range e.Detail.PackageVulnerabilityDetails.VulnerablePackages {
		pk := api.Package{
			Arch:            p.Arch,
			Epoch:           p.Epoch,
			Name:            p.Name,
			PackageManager:  p.PackageManager,
			Release:         p.Release,
			SourceLayerHash: p.SourceLayerHash,
			Version:         p.Version,
		}
		affectedPackages = append(affectedPackages, pk)
	}

	v := &api.VulnerabilityFinding{
		Title:               e.Detail.Title,
		VulnerabilityId:     e.Detail.PackageVulnerabilityDetails.VulnerabilityId,
		MessageSource:       messageSources.EventBridge,
		VulnerabilitySource: vulnerabilitySources.InspectorV2,
		RecievedTimestamp:   time.Now().String(),
		DetectedTimestamp:   e.Detail.FirstObservedAt,
		AffectedResourceIds: affectedResourceIds,
		AffectedPackages:	 affectedPackages,
		Severity:            e.Detail.Severity,
		RawEvent:            nil,
		Vex:                 vex,
	}
	return v, nil
}

func initLogger(verbosity int) error {
	if err := logger.InitZap(verbosity); err != nil {
		return fmt.Errorf("failed init zap logger in root command: %v", err)
	}

	return nil
}