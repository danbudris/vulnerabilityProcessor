package cmd

import (
	"context"
	"fmt"
	"github.com/danbudris/vulnerabilityProcessor/pkg/retier"

	"log"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sqs"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/danbudris/vulnerabilityProcessor/pkg/api"
	"github.com/danbudris/vulnerabilityProcessor/pkg/inspectorHelper"
	"github.com/danbudris/vulnerabilityProcessor/pkg/logger"
	"github.com/danbudris/vulnerabilityProcessor/pkg/messageSources"
	prcreator "github.com/danbudris/vulnerabilityProcessor/pkg/prManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/sqsHelper"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vulnerabilitySources"
	"github.com/danbudris/vulnerabilityProcessor/pkg/workflow"
)

const (
	sqsRegionFlag = "sqs-region"
	sqsDefaultRegion = "us-east-1"
	sqsUrlFlag = "sqs-url"
)

// SQS polling provider is experimental and unstable
var listenSqs = &cobra.Command{
	Use:   "sqs",
	Short: "Start a polling loop reading from an SQS queue for vulnerabilities",
	Long:  "Run a polling loop reading from the given SQS queue and processing vulnerabilities",
	RunE: func(cmd *cobra.Command, args []string) error {

		retrier := retier.New(10, retier.WithBackoffFactor(2.0), retier.WithMaxRetries(10, 5))
		o := &prcreator.Opts{
			SourceOwner: "danbudris",
			SourceRepo:  "vulnerabilityProcessor",
			PrRepo:      "vulnerabilityProcessor",
			PrRepoOwner: "danbudris",
		}
		prCreator := prcreator.New(retrier, o)

		sess, err := setupSession(viper.GetString(sqsRegionFlag))
		if err != nil {
			log.Fatalf("Error polling SQS queue: %v", err)
		}

		v, err := vexManager.New(viper.GetString(vexFilepathFlag))
		if err != nil {
			return fmt.Errorf("setting up vex manager: %v", err)
		}

		h := workflow.NewInspector(*v)

		prHandlerOpts := workflow.VexPrCreatorOpts{
			AuthorName:         "VEX PR Bot",
			AuthorEmail:        "d.c.budris@gmail.com",
			PrBranch:           "main",
			VexDocumentGitPath: "test.vex",
		}
		prH := workflow.VexPrCreatorHandler(v, prCreator, prHandlerOpts)
		h.SetNextHandler(prH)

		q := sqsHelper.NewSQS(sess, 1)

		err = processSqs(cmd.Context(), q, h, viper.GetString(sqsUrlFlag), v)
		if err != nil {
			log.Fatalf("Error getting image versions: %v", err)
		}
		return nil
	},
}

func init() {
	listenCmd.AddCommand(listenSqs)
	listenSqs.Flags().String(sqsUrlFlag, "", "AWS SQS queue URL")
	listenSqs.Flags().String(sqsRegionFlag, sqsDefaultRegion, fmt.Sprintf("The AWS region of the SQS queue to listen to. Defaults to %s", sqsDefaultRegion))
	err := viper.BindPFlags(listenSqs.Flags())
	if err != nil {
		log.Fatalf("Error initializing flags: %v", err)
	}
}

func setupSession(region string) (*session.Session, error){
	sess, err := session.NewSessionWithOptions(session.Options{
		Config: aws.Config{
			Region:                        aws.String(region),
			CredentialsChainVerboseErrors: aws.Bool(true),
		},
	})
	if err != nil {
		return nil, fmt.Errorf("setting up session: %v", err)
	}
	return sess, nil
}

func processSqs(ctx context.Context, q sqsHelper.SQS, h workflow.VulnerabilityHandler, sqsQueueUrl string, vex *vexManager.Manager) error {
	chnMessages := make(chan *sqs.Message, 1)
	go q.Poll(ctx, chnMessages, sqsQueueUrl, 1)

	logger.Info("Listening to queue", "queue", sqsQueueUrl)

	for message := range chnMessages {
		v, err := inspectorSourceMessageToVulnerabilityFinding(message, vex)
		if err != nil {
			logger.Error(err, "creating vulnerabilityFinding from SQS message with Inspector source")
		}
		wCtx := workflow.NewContext()

		err = h.Handle(ctx, wCtx, v)
		if err != nil {
			logger.Error(err, "handling finding")
		}
		if err == nil {
			err = q.Delete(ctx, sqsQueueUrl, *message.ReceiptHandle)
			if err != nil {
				logger.Error(err, "deleting sqs message ", "queue", sqsQueueUrl, "message", message.MessageId)
			}
		}
		if err != nil {
			logger.Error(err, "handling sqs message", "queue", sqsQueueUrl, "message", message.MessageId)
		}
	}
	return nil
}

func inspectorSourceMessageToVulnerabilityFinding(msg *sqs.Message, vex *vexManager.Manager) (*api.VulnerabilityFinding, error) {
	b := []byte(*msg.Body)
	f, err := inspectorHelper.ReadFindingFromBytes(b)
	if err != nil {
		return nil, fmt.Errorf("reading inspector finding: %v", err)
	}

	var affectedResourceIds []string
	for _, r := range f.Resources {
		affectedResourceIds = append(affectedResourceIds, r.Id)
	}

	v := &api.VulnerabilityFinding{
		VulnerabilityId:     f.PackageVulnerabilityDetails.VulnerabilityId,
		MessageSource:       messageSources.Sqs,
		VulnerabilitySource: vulnerabilitySources.InspectorV2,
		RecievedTimestamp:   time.Now().String(),
		DetectedTimestamp:   f.FirstObservedAt,
		AffectedResourceIds: affectedResourceIds,
		Severity:            f.Severity,
		RawEvent:            b,
		Vex:                 vex,
	}
	return v, nil
}
