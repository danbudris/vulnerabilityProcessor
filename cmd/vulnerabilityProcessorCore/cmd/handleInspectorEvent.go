package cmd

import (
	"fmt"
	"log"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/danbudris/vulnerabilityProcessor/pkg/api"
	"github.com/danbudris/vulnerabilityProcessor/pkg/inspectorHelper"
	"github.com/danbudris/vulnerabilityProcessor/pkg/issueManager"
	prcreator "github.com/danbudris/vulnerabilityProcessor/pkg/prManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/vexManager"
	"github.com/danbudris/vulnerabilityProcessor/pkg/workflow"
)

const (
	owner = "danbudris"
	repo = "vulnerabilityProcessor"
	inspectorFindingEventInputFlag = "inspectorFindingEvent"
)

var handleInspectorEvent = &cobra.Command{
	Use:   "inspectorEvent",
	Short: "handle an Inspector V2 EventBridge Event",
	Long:  "Ingest an Inspector V2 EventBridge Event and execute a chain of handlers to process it",
	RunE: func(cmd *cobra.Command, args []string) error {

		fmt.Printf("VIPER flags: %v", viper.GetString(vexFilepathFlag))

		o := &prcreator.Opts{
			SourceOwner: owner,
			SourceRepo:  repo,
			PrRepo:      repo,
			PrRepoOwner: owner,
		}
		prCreator := prcreator.New(o)

		v, err := vexManager.New(viper.GetString(vexFilepathFlag))
		if err != nil {
			return fmt.Errorf("setting up vex manager: %v", err)
		}

		inspectorHandler := workflow.NewInspector(*v)

		prHandlerOpts := workflow.VexPrCreatorOpts{
			AuthorName:         "VEX PR Bot",
			AuthorEmail:        "d.c.budris@gmail.com",
			PrBranch:           "main",
			VexDocumentGitPath: "test.vex",
		}
		prHandler := workflow.VexPrCreatorHandler(v, prCreator, prHandlerOpts)

		issueManagerOpts := &issueManager.Opts{
			SourceOwner: owner,
			SourceRepo:  repo,
		}
		issueManager := issueManager.New(issueManagerOpts)

		issueHandlerOpts := workflow.GithubIssueCreatorOpts{
			Labels: &[]string{"hey", "there", "test"},
		}
		issueHandler := workflow.IssueCreatorHandler(v, issueManager, issueHandlerOpts)

		prHandler.SetNextHandler(issueHandler)
		inspectorHandler.SetNextHandler(prHandler)

		wCtx := workflow.NewContext()
		wCtx.SetVex(v)

		vulnerability, err := inspectorEventBridgeEventToVulnerabilityFinding([]byte(viper.GetString(inspectorFindingEventInputFlag)), *v)
		if err != nil {
			return fmt.Errorf("converting InspectorV2 EventBridge event to vulnerabilitiy finding: %v", err)
		}
		wCtx.AddVulnerabilitiy(vulnerability)

		return inspectorHandler.Handle(cmd.Context(), wCtx, vulnerability)
	},
}

func init() {
	handleCmd.AddCommand(handleInspectorEvent)
	handleInspectorEvent.Flags().String(inspectorFindingEventInputFlag, "", "Inspector EventBridge event")
	handleCmd.PersistentFlags().StringP(vexFilepathFlag, "f", "", "Filepath of the VEX document to associate with the handler")
	err := viper.BindPFlags(handleInspectorEvent.Flags())
	if err != nil {
		log.Fatalf("Error initializing flags: %v", err)
	}
}

func inspectorEventBridgeEventToVulnerabilityFinding(eventBytes []byte, vex vexManager.Manager) (*api.VulnerabilityFinding, error) {
	f, err := inspectorHelper.ReadFindingFromBytes(eventBytes)
	if err != nil {
		return nil, fmt.Errorf("reading inspector finding: %v", err)
	}
	v := &api.VulnerabilityFinding{
		VulnerabilityId:     f.PackageVulnerabilityDetails.VulnerabilityId,
		MessageSource:       api.EventBridge,
		VulnerabilitySource: api.InspectorV2VulnerabilitySource,
		RecievedTimestamp:   time.Now().String(),
		DetectedTimestamp:   f.FirstObservedAt,
		AffectedResourceId:  f.Resources[0].Id,
		Severity:            f.Severity,
		RawEvent:            eventBytes,
		Vex:                 vex,
	}
	return v, nil
}
